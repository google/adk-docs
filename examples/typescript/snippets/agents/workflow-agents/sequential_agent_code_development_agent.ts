// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import { SequentialAgent, LlmAgent, InMemoryRunner, isFinalResponse } from '@google/adk';
import { createUserContent } from '@google/genai';

// --- Constants ---
const APP_NAME = "code_pipeline_app";
const USER_ID = "dev_user_01";
const SESSION_ID = "pipeline_session_02"; // Use a unique session ID for each run if desired
const GEMINI_MODEL = "gemini-2.5-flash";


// --8<-- [start:init]
// Part of agent.ts --> Follow https://google.github.io/adk-docs/get-started/quickstart/ to learn the setup

// --- 1. Define Sub-Agents for Each Pipeline Stage ---

// Code Writer Agent
// Takes the initial specification (from user query) and writes code.
const codeWriterAgent = new LlmAgent({
    name: "CodeWriterAgent",
    model: GEMINI_MODEL,
    instruction: `You are a Python Code Generator.
Based *only* on the user's request, write Python code that fulfills the requirement.
Output *only* the complete Python code block, enclosed in triple backticks (\`\`\`python ... \`\`\`). 
Do not add any other text before or after the code block.
`,
    description: "Writes initial Python code based on a specification.",
    outputKey: "generated_code" // Stores output in state['generated_code']
});

// Code Reviewer Agent
// Takes the code generated by the previous agent (read from state) and provides feedback.
const codeReviewerAgent = new LlmAgent({
    name: "CodeReviewerAgent",
    model: GEMINI_MODEL,
    instruction: `You are an expert Python Code Reviewer. 
    Your task is to provide constructive feedback on the provided code.

    **Code to Review:**
    \`\`\`python
    {generated_code}
    \`\`\`

**Review Criteria:**
1.  **Correctness:** Does the code work as intended? Are there logic errors?
2.  **Readability:** Is the code clear and easy to understand? Follows PEP 8 style guidelines?
3.  **Efficiency:** Is the code reasonably efficient? Any obvious performance bottlenecks?
4.  **Edge Cases:** Does the code handle potential edge cases or invalid inputs gracefully?
5.  **Best Practices:** Does the code follow common Python best practices?

**Output:**
Provide your feedback as a concise, bulleted list. Focus on the most important points for improvement.
If the code is excellent and requires no changes, simply state: "No major issues found."
Output *only* the review comments or the "No major issues" statement.
`,
    description: "Reviews code and provides feedback.",
    outputKey: "review_comments", // Stores output in state['review_comments']
});


// Code Refactorer Agent
// Takes the original code and the review comments (read from state) and refactors the code.
const codeRefactorerAgent = new LlmAgent({
    name: "CodeRefactorerAgent",
    model: GEMINI_MODEL,
    instruction: `You are a Python Code Refactoring AI.
Your goal is to improve the given Python code based on the provided review comments.

  **Original Code:**
  \`\`\`python
  {generated_code}
  \`\`\`

  **Review Comments:**
  {review_comments}

**Task:**
Carefully apply the suggestions from the review comments to refactor the original code.
If the review comments state "No major issues found," return the original code unchanged.
Ensure the final code is complete, functional, and includes necessary imports and docstrings.

**Output:**
Output *only* the final, refactored Python code block, enclosed in triple backticks (\`\`\`python ... \`\`\`). 
Do not add any other text before or after the code block.
`,
    description: "Refactors code based on review comments.",
    outputKey: "refactored_code", // Stores output in state['refactored_code']
});


// --- 2. Create the SequentialAgent ---
// This agent orchestrates the pipeline by running the sub_agents in order.
const rootAgent = new SequentialAgent({
    name: "CodePipelineAgent",
    subAgents: [codeWriterAgent, codeReviewerAgent, codeRefactorerAgent],
    description: "Executes a sequence of code writing, reviewing, and refactoring.",
    // The agents will run in the order provided: Writer -> Reviewer -> Refactorer
});

// --8<-- [end:init]

// --- 3. Running the Agent (Using InMemoryRunner for local testing) ---

const runner = new InMemoryRunner({agent: rootAgent, appName: APP_NAME});
console.log(`InMemoryRunner created for agent '${rootAgent.name}'.`);


// --- Interaction Function ---
async function callCodePipeline(query: string, userId: string, sessionId: string): Promise<string | null> {
    console.log(`
=============== Running Code Pipeline for Query: '${query}' ===============`);
    console.log(`Attempting to use Session ID: ${sessionId}`);
    const content = createUserContent(query);
    let finalCode: string | null = null;
    const pipelineStepOutputs: {[key: string]: string} = {};

    // --- Explicit Session Creation/Check BEFORE run ---
    const sessionService = runner.sessionService;
    await sessionService.createSession({appName: APP_NAME, userId, sessionId});
  
    // --- Run the Agent ---
    for await (const event of runner.runAsync({
        userId,
        sessionId,
        newMessage: content,
    })) {
        const authorName = event.author || "System";

        if (isFinalResponse(event) && event.content?.parts?.length) {
            const outputText = event.content.parts[0].text!.trim();
            pipelineStepOutputs[authorName] = outputText;

            console.log(`\n--- Output from: ${authorName} ---`);
            console.log(outputText);
            console.log("- ".repeat(authorName.length + 18));

            if (authorName === codeRefactorerAgent.name) {
                finalCode = outputText;
            }
        } else if (event.errorMessage) {
              // Log error but allow loop to continue if possible
              console.log(`  -> Error from ${authorName}: ${event.errorMessage}`);
        }
    }

    if (!finalCode) {
        console.log("\nPipeline did not produce final refactored code.");
    }

    // --- Final State Retrieval ---
    console.log("\n--- Attempting to retrieve Final Session State ---");
    let finalSessionObject;
    try {
        finalSessionObject = await runner.sessionService.getSession({
            appName: APP_NAME,
            userId,
            sessionId,
        });
    } catch (e) {
         console.log(`   -> Error retrieving final session object: ${e}`);
    }

    if (finalSessionObject) {
        console.log(finalSessionObject.state);
    } else {
        console.log("State not found (Final session object could not be retrieved).");
    }
    console.log("=".repeat(50));

    return finalCode;
}


async function main() {
    const query = "Write a Python function to calculate the factorial of a number using recursion.";
    // const query = "Create a simple Python class for a 'Book' with attributes title and author.";
    // const query = "Generate a Python function that takes a list of numbers and returns the sum of squares.";
    // const query = "Write a Python script to read the first line of a text file named 'input.txt'.";

    await callCodePipeline(query, USER_ID, SESSION_ID);
}

main();
